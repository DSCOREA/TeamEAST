<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>벽돌깨기 게임 (레벨 & 라이프 추가)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #000;
      overflow: hidden;
      user-select: none;
    }
    canvas {
      display: block;
      border: 2px solid #fff;
      background: #111;
    }
    #restartButton {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, 50px);
      padding: 10px 20px;
      font-size: 18px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: none;
    }
    #restartButton:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
<script>
let paddle, ball, bricks, restartButton;
const paddleWidth = 100;
const paddleHeight = 10;
const ballSize = 10;
let ballSpeedX = 4;
let ballSpeedY = -4;

const brickRowCount = 5;
const brickColumnCount = 8;
const brickWidth = 75;
const brickHeight = 20;
const brickPadding = 10;
const brickOffsetTop = 30;
const brickOffsetLeft = 30;

let score = 0;
let gameOver = false;
let lives = 3;
let level = 1;
let isLevelCleared = false;
let levelClearTimer = 0;

function setup() {
  createCanvas(800, 600);

  restartButton = createButton("다시 시작");
  restartButton.id("restartButton");
  restartButton.mousePressed(resetGame);
  resetGame();
  textFont('Arial, sans-serif');
  textAlign(LEFT, TOP);
}

function resetGame() {
  paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
  ball = createVector(width / 2, height - 30);
  ballSpeedX = 4 + (level - 1) * 0.8; // 레벨당 속도 증가
  ballSpeedY = -4 - (level - 1) * 0.8;
  score = 0;
  lives = 3;
  level = 1;
  gameOver = false;
  isLevelCleared = false;
  generateBricks();
  restartButton.hide();
  loop();
}

function generateBricks() {
  bricks = [];
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {
        x: 0,
        y: 0,
        status: 1,
      };
    }
  }
}

// 다음 레벨 초기화
function nextLevel() {
  level++;
  ball = createVector(width / 2, height - 30);
  ballSpeedX = 4 + (level - 1) * 0.8;
  ballSpeedY = -4 - (level - 1) * 0.8;
  paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
  isLevelCleared = false;
  generateBricks();
  levelClearTimer = 0;
  loop();
}

function draw() {
  background(0);

  drawPaddle();
  drawBall();
  drawBricks();
  drawScoreLivesLevel();

  if (gameOver) {
    fill(255, 50, 50);
    textSize(48);
    textAlign(CENTER, CENTER);
    text("게임 오버!\n최종 점수: " + score + "\nR키 또는 버튼으로 재시작", width / 2, height / 2);
    restartButton.show();
    noLoop();
    return;
  }

  if (isLevelCleared) {
    fill(255, 255, 0);
    textSize(36);
    textAlign(CENTER, CENTER);
    text(`Level ${level} 클리어!`, width / 2, height / 2 - 40);
    textSize(24);
    text(`다음 레벨로 넘어갑니다...`, width / 2, height / 2 + 10);

    levelClearTimer += deltaTime;
    if (levelClearTimer > 1000) {
      nextLevel();
    }
    return; // 다음 레벨 전까지 게임 진행 일시 중지
  }

  handleInput();
  moveBall();
  checkCollisions();
}

function drawPaddle() {
  fill(255);
  rect(paddle.x, paddle.y, paddleWidth, paddleHeight, 5);
}

function drawBall() {
  fill(0, 255, 255);
  ellipse(ball.x, ball.y, ballSize, ballSize);
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;

        // 벽돌 색상: 레벨별, 행별로 다르게
        let baseHue = (level * 50 + r * 40) % 360;
        colorMode(HSL, 360, 100, 50);
        fill(baseHue, 80, 55);
        rect(brickX, brickY, brickWidth, brickHeight, 4);
        colorMode(RGB, 255);
      }
    }
  }
}

function drawScoreLivesLevel() {
  fill(255);
  textSize(18);
  textAlign(LEFT, TOP);
  text(`점수: ${score}`, 10, 10);
  text(`라이프: ${lives}`, 10, 35);
  text(`레벨: ${level}`, 10, 60);
}

function handleInput() {
  if (keyIsDown(LEFT_ARROW)) {
    paddle.x -= 7;
  }
  if (keyIsDown(RIGHT_ARROW)) {
    paddle.x += 7;
  }
  if (touches.length > 0) {
    let touchX = touches[0].x;
    paddle.x = touchX - paddleWidth / 2;
  }
  paddle.x = constrain(paddle.x, 0, width - paddleWidth);
}

function moveBall() {
  ball.x += ballSpeedX;
  ball.y += ballSpeedY;

  // 좌우 벽 반사
  if (ball.x < ballSize / 2) {
    ball.x = ballSize / 2;
    ballSpeedX *= -1;
  }
  if (ball.x > width - ballSize / 2) {
    ball.x = width - ballSize / 2;
    ballSpeedX *= -1;
  }
  // 위 벽 반사
  if (ball.y < ballSize / 2) {
    ball.y = ballSize / 2;
    ballSpeedY *= -1;
  }
  // 바닥에 닿으면 라이프 감소
  if (ball.y > height) {
    lives--;
    if (lives <= 0) {
      gameOver = true;
    } else {
      // 라이프 남으면 공 위치 및 속도 초기화 (현재 레벨 속도 유지)
      ball = createVector(width / 2, height - 30);
      ballSpeedX = 4 + (level - 1) * 0.8;
      ballSpeedY = -4 - (level - 1) * 0.8;
      // 패들 중앙으로 이동
      paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
      noLoop();
      setTimeout(loop, 1000);
    }
  }
}

function checkCollisions() {
  // 패들 충돌 처리 - 공이 패들에 닿으면 튕기는데 패들 좌우 위치에 따라 각도 조정
  if (
    ball.y + ballSize / 2 >= paddle.y &&
    ball.y + ballSize / 2 <= paddle.y + paddleHeight &&
    ball.x >= paddle.x &&
    ball.x <= paddle.x + paddleWidth &&
    ballSpeedY > 0
  ) {
    // 반사
    ballSpeedY *= -1;

    // 패들 중앙을 기준으로 공의 x 위치에 따라 X 속도 조정 (-5 ~ 5 범위)
    let hitPoint = ball.x - (paddle.x + paddleWidth / 2);
    ballSpeedX = map(hitPoint, -paddleWidth / 2, paddleWidth / 2, -7, 7);
    ball.y = paddle.y - ballSize / 2; // 공이 패들 아래 들어가지 않도록 위치 조정
  }

  // 벽돌 충돌
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r];
      if (b.status === 1) {
        if (
          ball.x + ballSize / 2 > b.x &&
          ball.x - ballSize / 2 < b.x + brickWidth &&
          ball.y + ballSize / 2 > b.y &&
          ball.y - ballSize / 2 < b.y + brickHeight
        ) {
          ballSpeedY *= -1;
          b.status = 0;

          // 벽돌 위치에 따라 점수 차등 부여 (위쪽이 더 높음)
          score += (brickRowCount - r) * 10;

          // 모든 벽돌이 깨졌는지 확인
          if (isAllBricksCleared()) {
            isLevelCleared = true;
            noLoop();
          }

          return; // 한 번에 여러 벽돌 충돌 방지
        }
      }
    }
  }
}

function isAllBricksCleared() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        return false;
      }
    }
  }
  return true;
}

function keyPressed() {
  if (gameOver && (key === "r" || key === "R")) {
    resetGame();
  }
}
</script>
</body>
</html>
