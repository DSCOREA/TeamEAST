<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0" />
  <title>벽돌깨기 모바일 대응</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #000;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    canvas {
      display: block;
      border: 2px solid #fff;
      background: #111;
      touch-action: none;
    }
    #restartButton {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, 50px);
      padding: 10px 20px;
      font-size: 18px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: none;
    }
    #restartButton:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
<script>
let paddle, ball, bricks, restartButton;
const paddleWidth = 100;
const paddleHeight = 10;
const ballSize = 10;
let ballSpeedX = 4;
let ballSpeedY = -4;

const brickRowCount = 5;
const brickColumnCount = 8;
const brickWidth = 75;
const brickHeight = 20;
const brickPadding = 10;
const brickOffsetTop = 80;   // 블럭 시작점 더 아래로 조정(점수판 공간 확보)
const brickOffsetLeft = 30;

let score = 0;
let gameOver = false;
let lives = 3;
let level = 1;
let isLevelCleared = false;
let levelClearTimer = 0;
let dragging = false;      // 패들을 드래그/터치로 조작할 때 사용하는 변수

function setup() {
  createCanvas(800, 600);

  restartButton = createButton("다시 시작");
  restartButton.id("restartButton");
  restartButton.mousePressed(resetGame);
  resetGame();
  textFont('Arial, sans-serif');
  textAlign(LEFT, TOP);
}

function resetGame() {
  paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
  ball = createVector(width / 2, height - 30);
  ballSpeedX = 4 + (level - 1) * 0.8;
  ballSpeedY = -4 - (level - 1) * 0.8;
  score = 0;
  lives = 3;
  level = 1;
  gameOver = false;
  isLevelCleared = false;
  generateBricks();
  restartButton.hide();
  loop();
}

function generateBricks() {
  bricks = [];
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {
        x: 0,
        y: 0,
        status: 1,
      };
    }
  }
}

function nextLevel() {
  level++;
  ball = createVector(width / 2, height - 30);
  ballSpeedX = 4 + (level - 1) * 0.8;
  ballSpeedY = -4 - (level - 1) * 0.8;
  paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
  isLevelCleared = false;
  generateBricks();
  levelClearTimer = 0;
  loop();
}

function draw() {
  background(0);

  drawScoreLivesLevel();
  drawBricks();
  drawPaddle();
  drawBall();

  if (gameOver) {
    fill(255, 50, 50);
    textSize(48);
    textAlign(CENTER, CENTER);
    text("게임 오버!\n최종 점수: " + score + "\nR키 또는 버튼으로 재시작", width / 2, height / 2 + 30);
    restartButton.show();
    noLoop();
    return;
  }

  if (isLevelCleared) {
    fill(255, 255, 0);
    textSize(36);
    textAlign(CENTER, CENTER);
    text(`Level ${level} 클리어!`, width / 2, height / 2 - 40);
    textSize(24);
    text(`다음 레벨로 넘어갑니다...`, width / 2, height / 2 + 10);

    levelClearTimer += deltaTime;
    if (levelClearTimer > 1000) {
      nextLevel();
    }
    return;
  }

  handleInput();
  moveBall();
  checkCollisions();
}

function drawPaddle() {
  fill(255);
  rect(paddle.x, paddle.y, paddleWidth, paddleHeight, 5);
}

function drawBall() {
  fill(0, 255, 255);
  ellipse(ball.x, ball.y, ballSize, ballSize);
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;

        let baseHue = (level * 50 + r * 40) % 360;
        colorMode(HSL, 360, 100, 50);
        fill(baseHue, 80, 55);
        rect(brickX, brickY, brickWidth, brickHeight, 4);
        colorMode(RGB, 255);
      }
    }
  }
}

function drawScoreLivesLevel() {
  fill(255,255,255);
  textSize(20);
  textAlign(LEFT, TOP);
  // 상단에 고정(좌측에서 brickOffsetTop=80보다 위에)
  text(`점수: ${score}   라이프: ${lives}   레벨: ${level}`, 16, 20);
}

function handleInput() {
  // 좌우 화살표 지원
  if (keyIsDown(LEFT_ARROW)) paddle.x -= 7;
  if (keyIsDown(RIGHT_ARROW)) paddle.x += 7;

  // 드래그/터치, 마우스 이동으로 패들 따라가기
  if (dragging && (mouseIsPressed || touches.length > 0)) {
    // 터치, 클릭 모두 지원
    let pointerX = touches.length > 0 ? touches[0].x : mouseX;
    paddle.x = pointerX - paddleWidth / 2;
  }

  // 범위 제한
  paddle.x = constrain(paddle.x, 0, width - paddleWidth);
}

// 마우스 클릭 또는 터치 시작시 드래깅
function mousePressed() {
  // 마우스로 패들 클릭했거나, 화면 어디든 터치하면 시작
  dragging = true;
  return false;
}
function mouseReleased() {
  dragging = false;
  return false;
}
function touchStarted() {
  dragging = true;
  return false;
}
function touchEnded() {
  dragging = false;
  return false;
}

function moveBall() {
  ball.x += ballSpeedX;
  ball.y += ballSpeedY;

  // 좌우
  if (ball.x < ballSize / 2) {
    ball.x = ballSize / 2;
    ballSpeedX *= -1;
  }
  if (ball.x > width - ballSize / 2) {
    ball.x = width - ballSize / 2;
    ballSpeedX *= -1;
  }
  // 위
  if (ball.y < ballSize / 2) {
    ball.y = ballSize / 2;
    ballSpeedY *= -1;
  }
  // 바닥
  if (ball.y > height) {
    lives--;
    if (lives <= 0) {
      gameOver = true;
    } else {
      ball = createVector(width / 2, height - 30);
      ballSpeedX = 4 + (level - 1) * 0.8;
      ballSpeedY = -4 - (level - 1) * 0.8;
      paddle = createVector(width / 2 - paddleWidth / 2, height - 20);
      noLoop();
      setTimeout(loop, 1000);
    }
  }
}

function checkCollisions() {
  // 패들 충돌(터치 위치 포함)
  if (
    ball.y + ballSize / 2 >= paddle.y &&
    ball.y + ballSize / 2 <= paddle.y + paddleHeight &&
    ball.x >= paddle.x &&
    ball.x <= paddle.x + paddleWidth &&
    ballSpeedY > 0
  ) {
    ballSpeedY *= -1;
    let hitPoint = ball.x - (paddle.x + paddleWidth / 2);
    ballSpeedX = map(hitPoint, -paddleWidth / 2, paddleWidth / 2, -7, 7);
    ball.y = paddle.y - ballSize / 2;
  }

  // 벽돌 충돌
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r];
      if (b.status === 1) {
        if (
          ball.x + ballSize / 2 > b.x &&
          ball.x - ballSize / 2 < b.x + brickWidth &&
          ball.y + ballSize / 2 > b.y &&
          ball.y - ballSize / 2 < b.y + brickHeight
        ) {
          ballSpeedY *= -1;
          b.status = 0;
          score += (brickRowCount - r) * 10;

          if (isAllBricksCleared()) {
            isLevelCleared = true;
            noLoop();
          }
          return;
        }
      }
    }
  }
}

function isAllBricksCleared() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        return false;
      }
    }
  }
  return true;
}

function keyPressed() {
  if (gameOver && (key === "r" || key === "R")) resetGame();
}
</script>
</body>
</html>
